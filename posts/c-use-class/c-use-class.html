<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ar" xml:lang="ar">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>استخدام البرمجة كائنية التوجه مع السي</title>
<meta name="author" content="محمود ناجي آدم" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Aref+Ruqaa">
<style type="text/css">
/******************************************************
* I copied these styles from markdotto.com, who is
* the creator of bootstrap, and I also did some
* modification. Thanks Mark for the beautiful theme,
* so I reserved the @mdo sign below.
*****************************************************/

/*
__
__                  /\ \
/'_`\_    ___ ___    \_\ \    ___
/'/'_` \ /' __` __`\  /'_` \  / __`\
/\ \ \L\ \/\ \/\ \/\ \/\ \L\ \/\ \L\ \
\ \ `\__,_\ \_\ \_\ \_\ \___,_\ \____/
\ `\_____\\/_/\/_/\/_/\/__,_ /\/___/
`\/_____/

*/



/* Body resets
-------------------------------------------------- */

* {
-webkit-box-sizing:  border-box;
-moz-box-sizing:  border-box;
box-sizing:  border-box;
}
html, body {
margin:  0;
padding:  0;
}
html {
font-size:  62.5%;
}
.header {
text-align: center;
overflow: hidden;
padding-top: 10px;
padding-bottom: 10px;
box-shadow: 0 0px 10px 0px rgba(0, 0, 0, 0.2);
}
.header a {
color: black;
padding: 12px;
text-decoration: none;
font-size: 18px;
}
.page_hover:hover {
box-shadow: 0 2px 7px 2px rgba(0, 0, 0, 0.3);
}
.header a.logo {
font-size: 70px;
font-weight: bold;
font-family: Aref Ruqaa;
}
body {
padding:  20px;
font-size:  14px;
line-height:  1.5;
color:  #444;
background-color:  #fff;
direction: rtl;
}
p {
margin:  0 0 20px;
}
h1, h2, h3 {
position:  relative;
margin:  30px 0 20px;
font-weight:  bold;
color:  #111;
text-rendering:  optimizeLegibility;
}
h1:before, h2:before, h3:before {
position:  absolute;
top:  auto;
color:  #ccc;
display:  none;
}
h1:before {
content:  "";
right:  -1.25em;
}
h2:before {
content:  "*";
right:  -1.25em;
}
h3:before {
content:  "-";
right:  -1.5em;
}
i, em, b, strong {
padding-left:  .1em;
padding-right:  .1em;
}
b, strong {
font-weight:  bold;
color:  #333;
}
b:before, b: after, strong:before, strong: after {
content:  "*";
}
i:before, i: after, em:before, em: after {
content:  "/";
}
hr {
margin:  0;
border:  0;
}
hr: after {
display:  block;
margin:  20px 0;
content:  "----------------------------------------------------------------";
color:  #ccc;
}
ul, ol {
padding:  0;
margin:  0 0 20px;
}
code, pre {
font-family:  Menlo, Monaco, Consolas, "Courier New", monospace;
}
code {
color:  #d14;
}
code:before, code: after {
content:  "=";
color:  #ccc;
}
pre {
display:  block;
margin:  0 0 14px;
padding:  15px;
border-radius:  3px 3px 3px 3px;
font-size:  18px;
line-height:  28px;
background-color:  #f5f5f5;
white-space:  pre;
white-space:  pre-wrap;
word-break:  break-all;
word-wrap:  break-word;
}
blockquote {
padding:  0 0 0 20px;
margin:  0 30px 20px -22.5px;
color:  #999;
border-left:  8px solid #e5e5e5;
}
blockquote p: last-child {
margin-bottom:  0;
}
img {
display:  block;
margin:  0;
border-radius:  5px;
}
a {
font-weight:  inherit;
line-height:  inherit;
color:  #111;
text-decoration:  none;
}
p a {
font-weight:  inherit;
line-height:  inherit;
color:  #444;
text-decoration:  underline;
}
sup a:before {
content:  "[";
}
sup a: after {
content:  "]";
}
a: hover {
text-decoration:  underline;
}
table {
line-height:  2.5;
margin-bottom:  15px;
max-width:  100%;
width:  100%;
}
table td, table th {
padding:  0 15px;
}
table th.left, table td.left {
text-align:  left;
}
table th.right, table td.right {
text-align:  right;
}
/******************************************************/
/* body */
body {
margin:  0 auto;
max-width:  770px;
}
/* head */
.masthead {
color:  #888;
}
.masthead: after {
display:  block;
content:  '----------------------------------------------------------------';
margin:  10px 0;
color:  #ccc;
}
.masthead a {
color:  #333;
}
.masthead ul {
list-style:  none;
}
.masthead li {
display:  inline-block;
}
.masthead li + li:before {
display:  inline-block;
content:  "\00B7 \00a0";
color:  #ccc;
}
/* searchform*/
#searchform {
position:  absolute;
top:  54px;
right:  30.4%;
}
#searchform #s {
background:  url("/media/img/search.png") no-repeat 5px 6px;
box-shadow:  inset 0 1px 1px rgba(0,0,0,0.1);
border:  1px solid #ddd;
border-radius:  2px;
-moz-border-radius:  2px;
width:  90px;
height:  30px;
line-height:  12px;
padding:  4px 10px 4px 28px;

-webkit-transition-duration:  400ms;
-webkit-transition-property:  width, background;
-webkit-transition-timing-function:  ease;
-moz-transition-duration:  400ms;
-moz-transition-property:  width, background;
-moz-transition-timing-function:  ease;
-o-transition-duration:  400ms;
-o-transition-property:  width, background;
-o-transition-timing-function:  ease;
}
#searchform #s: focus {
background-color:  #f9f9f9;
width:  160px;
}
.masthead img.avatar {
position:  relative;
float:  right;
margin-top:  -100px;
margin-bottom:  -100%;
margin-right:  10%;
width:  200px;
background-color:  #fff;
}
/* post */
.post {
position:  relative;
}
.post: after {
display:  block;
content:  "----------------------------------------------------------------";
color:  #ccc;
}
.post img {
max-width:  100%;
}
.post li {
list-style:  none outside none;
}
.post ul > li:before {
content:  "- ";
margin-left:  -1.25em;
color:  #ccc;
}
.post ol {
counter-reset:  o-list;
}
.post ol > li:before {
content:  counter(o-list) ") ";
counter-increment:  o-list;
margin-left:  -1.85em;
color:  #ccc;
}

/* special for li in pre */
.post pre li {
list-style-type:  decimal;
}

.post pre li:before {
display:  none;
}

/* meta info */
.post-info {
display:  inline-block;
margin:  -10px 0 -10px;
color:  #999;
}
.post-info + .post-info:before {
content:  "\2223 \00a0";
}
.post-meta: after {
content:  "----------------------------------------------------------------";
display:  block;
margin-top:  -1px;
color:  #ccc;
}

#table-of-contents li {
color: #777;
text-decoration: underline;
}
#table-of-contents li a {
color: #555;
text-decoration: underline;
}
/* footer */
.footer {
margin:  80px 0 0;
text-align:  center;
font-size:  15px;
color:  #999;
}
.footer > p {
margin:  0;
line-height:  1.5;
}
.footpara {
display:  inline;
}
.org-src-container {
direction: ltr;
}
pre.src {
font-size: 14px;
}
pre.example {
font-size: 14px;
color: blue;
direction :ltr;
}

/* Responsive
-------------------------------------------------- */

@media (min-width:  768px) {
/* Increase body padding and font-sizes */
body {
padding:  30px;
font-size:  18px;
line-height:  1.75;
}
h1:before, h2:before, h3:before {
display:  inline;
}
}

@media (min-width:  1024px) {
body {
padding:  30px;
}
}
</style>
<link rel="stylesheet"
href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script>
<script>
// first, find all the div.code blocks
document.addEventListener('DOMContentLoaded', (event) => {
document.querySelectorAll('pre.src').forEach((el) => {
hljs.highlightElement(el);
});
});
</script>
<div class="header">
<a href="../../index.html" class="logo" >خواطر ناجي</a>
<br>
<a href="../../index.html" class="page_hover">الخواطر</a>
<a href="../../about.html" class="page_hover">عن المدونة</a>
<a href="../../aboutme.html" class="page_hover">عني</a>
</div>
</head>
<body>
<div id="content" class="content">
<h1 class="title">استخدام البرمجة كائنية التوجه مع السي
<br />
<span class="subtitle">بسم الله الرحمن الرحيم</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>قائمة المحتويات</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd73860b">المقدمة</a></li>
<li><a href="#org12f21ea">البرمجة كائنية التوجه</a></li>
<li><a href="#org1fa6efe">السي والبرمجة الكائنية</a></li>
<li><a href="#org31aada3">كيف نتعامل مع الهيكل ككائن؟</a></li>
<li><a href="#orge3b3f39">التحويل الى اسفل (Downcasting)</a></li>
<li><a href="#orgde61966">مثال اضافي</a></li>
<li><a href="#org7e12ac3">الملخص</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgd73860b" class="outline-2">
<h2 id="orgd73860b">المقدمة</h2>
<div class="outline-text-2" id="text-orgd73860b">
<p>
البرمجة كائنية التوجه (OOP) هي نوع برمجة مستخدم بشدة في كل لغات
البرمجة الحديثة، ولكن كما هو معروف السي لغة قائمة على البرمجة الوظيفية
(Functional programming)، واحيانا تطبيق بعض أفكار البرمجة الكائنية في
السي يحسن كثيرا فاعلية الكود وهيئته، ونرى ذلك في كود لينكس (Linux
Kernel)، فستجد استخدامات كثيرة للبرمجة الكائنية فيه، وفي هذا الخاطر
سوف أتحدث عن كيفية استخدام البرمجة كائنية التوجه في السي وسنوضح أمثلة
عليها.
</p>
</div>
</div>

<div id="outline-container-org12f21ea" class="outline-2">
<h2 id="org12f21ea">البرمجة كائنية التوجه</h2>
<div class="outline-text-2" id="text-org12f21ea">
<p>
سأعتمد أن القارئ يعرف البرمجة كائنية التوجه (OOP)، ولكن قبل أن أبدأ
سوف أتحدث عن جزئين مهمين فيها:
</p>
<ul class="org-ul">
<li><p>
الوراثة (Inheritance)
</p>

<p>
كما تعلم يا صديقي أن الوراثة في البرمجة الكائنية هي طريقة جيدة جدا
في وضع الصفات والطرق بطريقة طبقية منطقية، بحيث جعل كل كائن يرث من
الذي قبله الطرق والصفات، والمثال الاشهر على التوريث هي انشاء فصيلة
(Class) الثدييات وتكون فيها طرق (Methods) مثل يلد ويأكل مثلا،
ويستطيع وراثت ذلك فصيلتان اخريان مثل الحوت والقرد، لانهما فيهم نفس
الصفات الأولية -كلاهم ياكلون ويلدون- ومن هنا نرتب البرنامج في شكل
متدرج منطقي، وقد يبني على ذلك مثلا تفصيل اكثر مثل فصائل الحوت
الابيض والازرق التي تستطيع أن ترث من فصيلة الحوت.
</p></li>

<li><p>
تعددية الاشكال (Polymorphism)
</p>

<p>
تعددية الاشكال تستخدم فكرة الوراثة في جعل الكائن الواحد يستطيع ان
يعامل بكونه انواع اخري، وهذا نستطيع فهمة جيدا من المثال اللي ذكرناه
في الوراثة، فمثلا نسطيع أن نعامل الحوت الزرق والحوت الابيض علي
انهم فصيلت الحوت، وايضا ممكن أن نتعامل معهم على انهم فصيلة
الثدييات، ومن هنا تجد أن نفس الكائن نستطيع التعامل معه بأكثر من شكل
وصفة، والمثير ايضا في هذا المفهوم أن الحوت الازرق والشمبانزي
نستطيع أن نعاملهم معالمة فصيلة الثدييات بدون أن نجد مشكلة في
اختلافهم.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org1fa6efe" class="outline-2">
<h2 id="org1fa6efe">السي والبرمجة الكائنية</h2>
<div class="outline-text-2" id="text-org1fa6efe">
<p>
السي كما نعرف تستخدم البرمجة الوظيفية، وتعتمد علي مستخدم الدالة في
الاحتفاظ بالبينات المستخدمة مع الدالة، وهذا على عكس مفهوم التغليف
(Encapsulation) الذي يجمع المعلومات او الصفات مع الطرق في كائن واحد
وتسطيع التعامل معهم جميعا عن طريق الكائن.  وهذا المفهوم نسطيع تطبيقه
في السي عن طريق الهيكل (Struct) فمثلا دعنا نصنع هيكل لمضلع في هيئة
فصيلة.
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgb3152d4">typedef struct polygon polygon_t;
struct polygon {
      int nsides;                       /* عدد الضلوع */
      int (*cal_permiter)(polygon_t *); /* مؤشر لدالة لحساب المحيط */
      int (*cal_area)(polygon_t *);     /* مؤشر لدالة لحساب المساحة  */
};
</pre>
</div>


<p>
لاحظ استخدام مؤشرات الدوال سنستخدمهم لاحقا، ولكن لاحظ استخدام
<code>polygon_t</code> كوسيط (Parameter)، وهذا يطابق <code>self</code> في البرمجة الكائنية في
البايثون واستخدام <code>this</code> في بعض اللغات الكائنية، فستساعدنا لمعرفة
الكائن المطلوب استخدامه.
</p>

<p>
نستطيع أن نعتبر الهيكل Polygon كفصيلة مجردة (Abstract Class)، ومن هنا
نسطيع أن نقوم بصنع فصيلة ترثها مثل المربع والمستطيل. ولنقوم بذلك
يمكننا أن نصنع هيكلين اخريين ونجعل الهيكل Polygon احد اعضاء الهيكل.
</p>

<div class="org-src-container">
<pre class="src src-C" id="orge8d4055">typedef struct square square_t;
struct square {
    polygon_t polygon;          /* يرث هيكل المضلع */
    int length;                 /* طول المربع */
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C" id="orge8ebd16">
typedef struct rectangle rectangle_t;
struct rectangle {
    polygon_t polygon;          /* يرث هيكل المضلع */
    int length;                 /* طول المستطيل */
    int width;                 /* عرض المستطيل*/
};
</pre>
</div>

<p>
والان نستطيع أن نعتبر هذه وراثة، بحيث أن كل فصيلة جديدة إن ارادت وراثة
هيكل المضلع يمكنها فقط وضعه في الهيكل داخلها، وعندما نريد أن نعامل
المستطيل كمضلع نتعامل مع جزء المضلع الذي بداخله.
</p>
</div>
</div>

<div id="outline-container-org31aada3" class="outline-2">
<h2 id="org31aada3">كيف نتعامل مع الهيكل ككائن؟</h2>
<div class="outline-text-2" id="text-org31aada3">
<p>
ولآن لقد انشئنا هيكل يحاكي مفهوم الوراثة، ولكن حتى الان لانملك كائن او
شكل يشبه البرمجة الكائنية.  لكي نصنع كائن يمكننا أن نصنع دالة بناء
(Constructor)، لصنع ذلك لها وجهين: وجه باستخدام الحجز الثابت (Static
Allocation)، واخر باستخدام الحجز المتحرك (Dynamic allocation).  الفكرة
من دالة البناء هي استخدامها لنضع قيم مبدئية في متغيرات الهيكل، مثل
مؤشرات الدوال التي توجد في هيكل المضلع <code>cal_area ,cal_permiter</code>, والتي
يجب أن نجعلهم يشيرون الي دوال معينة كي نستطيع أن نستخدمهم لاحقا، بحيث
نحاكي فكرة التغليف.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org56c0c1d">
int rect_cal_area(polygon_t *poly)
{
    rectangle_t *rect = (rectangle_t *) poly; /* هنا نستخدم فكرة تعدد الاشكال */
    return rect-&gt;length * rect-&gt;width;
}

int rect_cal_permiter(polygon_t *poly)
{
    rectangle_t *rect = (rectangle_t *) poly; /* هنا نستخدم فكرة تعدد الاشكال */
    return 2 * (rect-&gt;length + rect-&gt;width);
}

void rect_init_static(rectangle_t *rect, int length, int width)
{
    rect-&gt;length = length;
    rect-&gt;width = width;
    rect-&gt;polygon.cal_permiter = rect_cal_permiter;
    rect-&gt;polygon.cal_area = rect_cal_area;
}

rectangle_t * rect_init(int length, int width)
{
    rectangle_t *rect = malloc(sizeof(rectangle_t));
    if (!rect)
        return NULL;
    rect-&gt;length = length;
    rect-&gt;width = width;
    rect-&gt;polygon.cal_permiter = rect_cal_permiter;
    rect-&gt;polygon.cal_area = rect_cal_area;
    return rect;
}
</pre>
</div>

<p>
في هذا الكود عرفنا دوال للمستطيل، ومنها الدوال لحسابة المحيط والمساحة،
وتري في الكود أعلاه أننا استخدمنا التحويل (casting) لنحول من نوع
<code>polygon_t</code> الي <code>rectangle_t</code>, واستطعنا أن نفعل ذلك لاننا نعرف أن من
يستخدم هذه الدوال من نوع <code>rectangle_t</code>, وايضا لاننا وضعنا ال <code>polygon</code> في
هيكل ال <code>rectangle_t</code> في المقدمة، والسي تأكد أن اول عضو في الهيكل دائما
يكون نفس عنوان الهيكل، وإحتجنا التحويل للتعامل مع المتغيرات في هيكل
المستطيل، وسيوضح كل شئ عندما نستخدمه الان.
</p>


<div class="org-src-container">
<pre class="src src-C">
int main()
{

    rectangle_t *rect1, rect2;
    polygon_t *poly1, *poly2;
    int area1, area2, prem1, prem2;

    rect1 = rect_init(5, 10); /* نستخدم الحجز المتحرك */
    rect_init_static(&amp;rect2, 3, 10); /* نستخدم الحجز الثابت */

    poly1 = &amp;rect1-&gt;polygon;    /* نستطيع ايضا أن نكتبها: poly1 = rect1 */
    poly2 = &amp;rect2.polygon;     /* نستطيع ايضا أن نكتبها: poly2 = &amp;rect2 */
    /* نحتاج إرسال نفس الهيكل كوسيط للدالة لكي تصل لصفات الكائن */
    area1 = poly1-&gt;cal_area(poly1);
    prem1 = poly1-&gt;cal_permiter(poly1);
    area2 = poly2-&gt;cal_area(poly2);
    prem2 = poly2-&gt;cal_permiter(poly2);

    printf("rect1: area:%d  prem:%d\n", area1, prem1);
    printf("rect2: area:%d  prem:%d\n", area2, prem2);
}
</pre>
</div>

<pre class="example">
rect1: area:50  prem:30
rect2: area:30  prem:26
</pre>



<p>
ومن الكود اعلاه نرى استخدام تعددية الاشكال، فاستطعنا أن نستخدم مؤشر من
نوع المضلع مع المستطيل، يمكننا ايضا أن نفعل الامر ذاته مع المربع، و
بهذا نستطيع استخدام نفس مؤشر المضلع لنشير الى مربع او مستطيل!
</p>

<p>
في حالة الحجز المتحرك سنحتاج أن نحرر الحجز، ولفعل ذلك نحتاج أن نكتب
دالة هدم (Deconstructer)، وفيها نستخدم دالة <code>free</code>
</p>
</div>
</div>

<div id="outline-container-orge3b3f39" class="outline-2">
<h2 id="orge3b3f39">التحويل الى اسفل (Downcasting)</h2>
<div class="outline-text-2" id="text-orge3b3f39">
<p>
لقد رأينا نوعين من التحويل، من المستطيل الي المضلع وهذا تحويل الي
اعلي، من الوارث الي الموروث، وهذا سهل لاننا نسطيع أن نستخدم العضو
<code>polygon</code> الذي في الهيكل لفعل ذلك.
</p>

<p>
أما التحويل إلى اسفل يحتاج الي الحيلة، استطعنا فعلها بسهولة مسبقا لانه
كان اول عضو في الهيكل، وأول عضو كما ذكرنا يملك نفس عنوان الهيكل كما
فعلنا في الدالتان <code>rect_cal_area</code> و <code>rect_cal_permiter</code>, ولكن ماذا لو كان
العضو الثاني في الهيكل؟ الاجابة هي <code>offsetof</code>, وهو مختصر (macro) معرف في
<b>stddef.h</b> يساعدك في حساب مكان العضو في الذاكرة بالنسبة الى الهيكل، ولكي
يحسب ذلك يحتاج الى وسيطين: اسم الهيكل، واسم العضو الذي تريد حساب
موقعه.
</p>

<div class="org-src-container">
<pre class="src src-C">struct test {
    int a;
    int b;
};

printf("offsetof(a) = %d\n", offsetof(struct test, a));
printf("offsetof(b) = %d\n", offsetof(struct test, b));
printf("ofssetof(b) - offsetof(a) = %d\n", offsetof(struct test, b) - offsetof(struct test, a));
</pre>
</div>

<pre class="example">
offsetof(a) = 0
offsetof(b) = 4
ofssetof(b) - offsetof(a) = 4
</pre>


<p>
كما نرى من المثال أن <code>b</code> تبعد عن <code>a</code> -و ايضاً من البداية- ٤ بايت، ويمكننا
استخدام تلك العملية للتحويل من مؤشر يشير إلي <code>b</code> إلي مؤشر يشير إلي
الهيكل كله..
</p>

<div class="org-src-container">
<pre class="src src-C">struct test {
    int a;
    int b;
};

struct test test = {
    .a = 1995,
    .b = 1312
};
int *pb = &amp;test.b;               /* وضع مؤشر علي b */
struct test *ptest;
ptest = (struct test*) ((char *)pb - offsetof(struct test, b));
printf("a: %d\nb: %d\n", ptest-&gt;a, ptest-&gt;b);
</pre>
</div>

<pre class="example">
a: 1995
b: 1312
</pre>


<p>
لنحلل هذا السطر اكثر:
</p>

<div class="org-src-container">
<pre class="src src-C">ptest = (struct test*) ((char *)pb - offsetof(struct test, b));
</pre>
</div>

<p>
اولا نحسب موقع <code>b</code> من الهيكل عن طريق <code>offsetof</code>, وكما نعرف انها ٤ بايتس، و
 الآن لكي نحول مؤشر <code>pb</code> إلي مؤشر <code>struct test</code>, يجب علينا طرح من المؤشر
 pb ٤ بايتس لكي نشير الي اول الهيكل، واحتجنا أن نحول pb الى مؤشر من
 نوع <code>char</code> لكي نطرح ٤ بايتس فقط، كما نعرف أن الجمع والطرح مع المؤشرات
 تستخدم نوع المؤشر، فجمع ٤ على مؤشر من نوع <code>int</code> لن يكون ٤ بايتس بل ١٦
 بايتس في حالة أن حجم int ٤ بايتس، ونحن هنا نريد فقط أن نطرح ٤ بايتس
 ولذلك احتجنا للتحويل لنوع يستخدم واحد بايت.  وبهذا استطعنا أن نحول
 الي اسفل. يمكننا ايضا كتابت هذه العملية في شكل مختصر كالتالي.
</p>

<div class="org-src-container">
<pre class="src src-C">
#define child_of(ptr, type, member) (type *) ((char *)ptr - offsetof(type, member))

int *pb = &amp;test.b;               /* وضع مؤشر علي b */
struct test *ptest;
ptest = child_of(pb, struct test, b);
printf("a: %d\nb: %d\n", ptest-&gt;a, ptest-&gt;b);

</pre>
</div>

<pre class="example">
a: 1995
b: 1312
</pre>


<p>
ايضا يمكنك البحث عن تعريف مختصر <b>container_of</b> في كود لينكس، معرف بشكل
اعمق قليلا من child_of التي ذكرناها في المثال، ولذلك انصح بالبحث عنه
ايضا.
</p>
</div>
</div>

<div id="outline-container-orgde61966" class="outline-2">
<h2 id="orgde61966">مثال اضافي</h2>
<div class="outline-text-2" id="text-orgde61966">
<p>
دعنا نكتب مثال يظهر المسألة اكثر، يمكننا أن نصنع مصفوفة من مؤشرات الي
polygon، ويمكننا أن ننشئ اكثر من نوع مثل مستطيل ومربع ومثلث مثلا،
و ننشى دالة تمشي على هذه المصفوفة وتطبع المساحة لهم جميعا.
</p>

<div class="org-src-container">
<pre class="src src-C">


void print_polygons(polygon_t *polgs[], int n)
{
    int i;
    for (i = 0; i &lt; n; i++) {
        int prem, area;
        prem = polgs[i]-&gt;cal_permiter(polgs[i]);
        area = polgs[i]-&gt;cal_area(polgs[i]);
        printf("polygon num %d: area=%d, perm=%d\n", i, area, prem);
    }
}

int main()
{

    rectangle_t *rect;
    square_t *square;
    triangle_t *triangle;
    polygon_t *polygons[3];

    rect = rect_init(5, 10); /* نستخدم الحجز المتحرك */
    triangle = triangle_init(2, 10, 3, 2); /* نستخدم الحجز المتحرك */
    square = square_init(5); /* نستخدم الحجز المتحرك */
    /* والآن لنضعهم في مصفوفة من نوع المضلع */
    polygons[0] = &amp;rect-&gt;polygon;
    polygons[1] = &amp;square-&gt;polygon;
    polygons[2] = &amp;triangle-&gt;polygon;

    print_polygons(polygons, 3);
}
</pre>
</div>

<pre class="example">
polygon num 0: area=50, perm=30
polygon num 1: area=25, perm=20
polygon num 2: area=10, perm=15
</pre>


<p>
كما نرى من المثال اننا استطعنا نبني دالة تمشي على مصفوفة من نوع المضلع،
وبهذا استطعنا أن نتعامل مع كل انواع المضلعات بنفس الدوال وبنفس
الطريقة، بدون التعامل معهم كحالات خاصة، وهذا يوضح قوة تعدد الاشكال.
</p>
</div>
</div>

<div id="outline-container-org7e12ac3" class="outline-2">
<h2 id="org7e12ac3">الملخص</h2>
<div class="outline-text-2" id="text-org7e12ac3">
<p>
تعلمنا في هذا الخاطر كيف نستخدم البرمجة الكائنية في السي، واستطعنا ان
نستخدم خصائصها ايضا مثل الوراثة وتعدد الاشكال، واسبتنا فاعلية
استخدامهم، وتكلمنا ايضا عن offsetof وكيف نستطيع أن نستخدمها للتحويل
إلي اسفل من موروث الى الوارث (أي من المضلع إلي المربع مثلا).  ويمكنك
البحث في كود لينكس وستجد أمثلة كثيرة لتطبيق ما ذكرناه، مثل استخدام
container_of، مع الكثير من برامج التعريف (Device Drivers).
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">بتاريخ: 2023-06-17 Sat 00:00</p>
<p class="author">تأليف: محمود ناجي آدم</p>
</div>
</body>
</html>
