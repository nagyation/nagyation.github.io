#+options: html-link-use-abs-url:nil html-postamble:auto
#+options: html-preamble:t html-scripts:nil html-style:t
#+options: html5-fancy:nil tex:t
#+options: num:0
#+options: timestamp:nil
#+html_doctype: xhtml-strict
#+html_container: div
#+html_content_class: content
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_equation_reference_format: \eqref{%s}
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2.50 (<a href="https://orgmode.org">Org</a> mode 9.5.5)
#+latex_header:
#+LANGUAGE: ar
#+AUTHOR: محمود ناجي آدم
#+EMAIL: contact@khawternagy.com
#+TITLE: استخدام البرمجة كائنية التوجه مع السي
#+subtitle: بسم الله الرحمن الرحيم
#+DATE: <2023-06-17 Sat>
#+SETUPFILE: ./../../css/white_clean.theme
#+SETUPFILE: ./../../css/post_header.org

* المقدمة
البرمجة كائنية التوجه (OOP) هي نوع برمجة مستخدم بشدة في كل لغات
البرمجة الحديثة، و لكن كما هو معروف السي لغة قائمة على البرمجة
الوظيفية (Functional programming)، و في هذا الخاطر سوف اتحدث عن كيفية
استخدام البرمجة كائنية التوجه في السي وسنذكر تشبيهات من ترميز النواة
لينيكس (Linux kernel code).

* البرمجة كائنية التوجه
سأعتمد أن القارئ يعرف البرمجة كائنية التوجه (OOP)، ولكن قبل ان أبدأ
سوف اتحدث عن جزئين مهمين فيها:
 - الوراثة (Inheritance)

   كما تعلم يا صديقي ان الوراثة في البرمجة الكائنية هي تريقة جيدة جدا
   في وضع الصفات والطرق بطريقة طبقية منطقية، بحيث ان كل كائن يرث من
   الذي قبله الطرق والصفات، والمثال الاشهر على التوريث هي انشاء فصيلة
   (Class) الثدييات وتكون فيها طرق (Methods) مثل يلد ويأكل مثلا،
   ويسطيع وراثت ذلك فصيلتان اخريان مثل الحوت والقرد، لانهما فيهم نفس
   الصفات الأولية -كلاهم ياكلون و يلدون- ومن هنا نرتب البرنامج في شكل
   متدرج منطقي، و قد يبني على ذلك مثلا تفصيل اكثر مثل قصائل الحوت
   الابيض و الازرق التي تستطيع ان ترث من فصيلة الحوت.

 - تعددية الاشكال (Polymorphism)

   تعددية الاشكال تستخدم فكرة الوراثة في جعل الكائن الواحد يستطيع ان
   يعامل بكونه انواع اخري، وهذا نستطيع فهمة جيدا من المثال اللي ذكرناه
   في الوراثة، فمثلا نسطيع ان نعامل الحوت الزرق و الحوت الابيض علي
   انهم فصيلت الحوت، و ايضا ممكن ان نتعامل معهم على انهم فصيلة
   الثدييات، ومن هنا تجد ان نفس الكائن نستطيع التعامل معه بأكثر من شكل
   و صفة، والمثير ايضا في هذا المفهوم أن الحوت الازرق والشامبنزي
   نستطيع ان نعاملهم معالمة فصيلة الثدييات بدون أن نجد مشكلة في
   اختلافهم.

* السي و البرمجة الكائنية

السي كما نعرف تستخدم البرمجة الوظيفية، وتعتمد علي مستخدم الدالة في أن
يحتفظ بمعلموت المستخدمة مع الدالة، و هذا على عكس مفهوم التغليف
(Encapsulation) الذي يجمع المعلومات او الصفات مع الطرق في شكل واحدة
وتسطيع التعامل معهم جميعا عن طريق الكائن.  و هذا المفهوم نسطيع ان نقوم
به في السي عن طريق الهيكل (Struct) فمثلا دعنا نصنع هيكل لمضلع في هيئة
فصيلة.

#+BEGIN_SRC C
  typedef struct polygon polygon_t;
  struct polygon {
        int nsides;                       /* عدد الضلوع */
        int (*cal_permiter)(polygon_t *); /* دالة لحساب المحيط */
        int (*cal_area)(polygon_t *);     /* دالة لحساب المساحة  */
  };
#+END_SRC


نستطيع ان نعتبر الهيكل Polygon كفصيلة مجردة (Abstract Class)، ومن هنا
نسطيع ان نقوم بصنع فصيلة ترثها مثل المربع و المستطيل. ولنقوم بذلك
يمكننا ان نصنع هيكلين اخريين ونجعل الهيكل Polygon احد اعضاء الهيكل.

#+BEGIN_SRC C
  typedef struct square square_t;

  struct square {
      polygon_t polygon;          /* يرث هيكل الضلع */
      int length;                 /* طول المربع */
  };

#+END_SRC

#+BEGIN_SRC C
  typedef struct rectangle rectangle_t;

  struct rectangle {
      polygon_t polygon;          /* يرث هيكل الضلع */
      int length;                 /* طول المستطيل */
      int width;                 /* عرض المستطيل*/
  };

#+END_SRC


والان نستطيع ان نعتبر هذة وراثة، بحيث ان كل فصيلة جديدة إن ارادت وراثة
هيكل المضلع يمكنها فقط وضعه في الهيكل داخلها، و عندما نريد ان نعامل
المستطيل كمضلع نتعامل مع جزء المضلع الذي بداخله.

* كيف نتعامل مع الهيكل ككائن؟

ولآن لقد انشئنا هيكل يحاكي مفهوم الوراثة، ولكن حتى الان لانملك كائن او
شكل يشبه البرمجة الكائنية.  لكي نصنع كائن يمكننا ان نصنع دالة بناء
(Constructor)، لصنع ذلك لها وجهين وجه باستخدام الحجز الثابت (Static
Allocation) واخر باستخدام الحجز المتحرك (Dynamic allocation).
